[{"heading":"My Journey Through Graduate Studies at NYU","date":"2025-05-01T04:00:00.000Z","introContent":"My experience through gradu studies at NYU.","keywords":["life experience","grad studies","NYU","USA"],"type":"life experience, opnion,","link":"","content":"I'm writing this two years after completing my Master’s in Scientific Computing at NYU. When I first applied to grad school, I had no intention of studying Computer Science. My interests lay in simulation sciences, and I was drawn to programs that combined mathematical depth with computational modeling. Scientific Computing felt like the perfect fit.\n\nAt the time, I applied to programs in Applied Mathematics and Computational Sciences. I didn’t apply to a single Computer Science program. My top choice was Stanford’s Computational Science program, though I didn’t get in. Still, I was fortunate to receive offers from two outstanding schools: Imperial College London and NYU Courant. The decision might seem difficult, but it wasn't. The UK was closer to home, but the academic environment and research freedom in the U.S. appealed to me more. So I chose New York.\n\nNYU Courant turned out to be a fantastic choice. It is one of the world’s leading institutions for applied mathematics, particularly in numerical computation. I joined with genuine excitement and selected courses based on curiosity and interest, not job-market calculations.\n\nThe program was a hybrid, jointly offered by the Mathematics and Computer Science departments. I hadn’t expected the CS classes to be filled with 40 to 50 percent Indian students, many of whom were focused on breaking into Big Tech. Meanwhile, I simply wanted to explore what fascinated me. Initially, that wasn’t Computer Science, but as I studied more, I grew to enjoy it. It seemed simpler than mathematics at first, and there were countless resources available online to learn from. Gradually, I found myself drawn deeper into the world of algorithms, systems, and software.\n\nHere’s a look at the courses I enrolled in during my time at NYU:\n\n\n## Courses Taken\n\n**Fall 2021**\n- Numerical Methods I  \n- Fundamental Algorithms  \n- Computer Graphics  \n\n**Spring 2022**\n- Numerical Methods II  \n- Machine Learning  \n- High Performance Computing  \n\n**Summer 2022**\n- Stochastic Calculus  \n- Programming Languages  \n\n**Fall 2022**\n- Computer Vision  \n- Monte Carlo Sampling Methods  \n- Distributed Systems  \n\n**Spring 2023**\n- Algorithmic Trading and Quantitative Strategies  \n\nMost of my course selections were either mandatory (such as Fundamental Algorithms, Numerical Methods I and II, and Programming Languages) or driven by personal curiosity. I dedicated a lot of time to hands-on projects, which turned out to be some of the most rewarding parts of the experience.\n\n\n## Projects and Research Work\n\n### Algorithms for Linear Algebra and Statistics\n- Implemented core algorithms for linear algebra and statistics from scratch using C++ and Python.  \n- Focused on numerical stability and performance optimization.\n\n\n### Exploring Computer Graphics: Fundamentals and Experiments\n- Developed a custom ray tracing pipeline in C++ to render complex geometry from open-source mesh and point cloud files.  \n- Improved rendering performance with spatial data structures such as bounding volume hierarchies.  \n- Built a complete CPU-based rasterization pipeline including shader implementations and transformation logic.  \n- Created an interactive desktop application for real-time 2D graphics manipulation.\n\n\n### Recommendation Systems: A Causal Inference Approach\n- Studied and implemented collaborative filtering and matrix factorization techniques.  \n- Introduced probabilistic latent factor models to explore causal relationships between user behavior and recommendations.  \n- Integrated causal inference to improve interpretability and performance of recommendation systems.\n\n\n### Parallelization of Algorithms for Graphs and Linear Algebra\n- Designed and implemented parallel graph algorithms on shared-memory architectures using OpenMP.  \n- Achieved speedups of 8x for Bellman-Ford, 7x for Connected Components, and 3x for Breadth-First Search on large graphs.  \n- Extended optimization algorithms using MPI and CUDA for heterogeneous computing environments.\n\n\n### Computer Vision: Semantic Segmentation with U-Nets\n- Applied semantic segmentation techniques to satellite imagery using different U-Net CNN architectures.  \n- Evaluated model performance on the Landcover.ai dataset with a variety of encoder backbones.\n\n\n### Monte Carlo Sampling Techniques\n- Implemented several Monte Carlo methods including importance sampling, ensemble methods, MCMC, and Langevin dynamics.  \n- Focused on statistical estimation in high-dimensional parameter spaces using parallel processing in Python.\n\n\n### Distributed Systems: Raft and Chord Protocols\n- Built a distributed key-value store using the Chord protocol for peer-to-peer networks with consistent hashing.  \n- Scaled performance from 100,000 to 1.6 million keys across 100 nodes and benchmarked fetch times.  \n- Implemented a replicated state machine using the Raft consensus algorithm, including leader election and fault tolerance.\n\n\n### Quantitative Analysis of Equity Market Data\n- Analyzed trades and quotes data for S&P 500 companies from June to September 2007 to study market impact.  \n- Built predictive models using statistical hypothesis testing and regression analysis to validate signal quality.\n\n\n## Closing Thoughts\n\nLooking back, NYU was a transformative chapter in my life. I learned more than I could have imagined, about computing, algorithms, data, and myself. Most importantly, I rediscovered the joy of being curious and following where that curiosity leads.","toBeDisplayed":true},{"heading":"Exploring LLMs, their frameworks, and the development of applications using them.","date":"2025-03-01T05:00:00.000Z","introContent":"A compilation of my understanding of LLM frameworks and how to build RAG applications using them.","keywords":["computer graphics","rasterization","C++"],"type":"implementation","link":"","content":"","toBeDisplayed":true},{"heading":"Fontend Technologies: Exploring, Experimenting, and Implementing","date":"2025-01-01T05:00:00.000Z","introContent":"I have been delving into the world of frontend development lately, and this document serves as a record of everything I have explored. Most of my time experimenting with frontend technologies has been focused on Next.js, React, and Material UI.","keywords":["frontend","TypeScript","JavaScript","React","Next.js","Angular","Material UI"],"type":"implementation","link":"","content":"","toBeDisplayed":true},{"heading":"Exploring Different Programming Languages","date":"2025-01-01T05:00:00.000Z","introContent":"The article is a compilation of my experiments with different programming languages, exploring their peculiarities, functionalities, and differences.","keywords":["C++","Go","TypeScript","JavaScript","Python","Elixir"],"type":"article","link":"","content":"","toBeDisplayed":true},{"heading":"A Structured Framework for Designing Scalable Distributed Systems","date":"2025-01-01T05:00:00.000Z","introContent":"This article presents the structured framework I have developed for addressing fundamental questions in the design of highly available and scalable systems.","keywords":["backend","database"],"type":"article","link":"https://utkarshkhandelwal.substack.com/p/understanding-the-components-of-software?r=rvgvb","content":"","toBeDisplayed":true},{"heading":"Concurrency and Parallelization: Implementations, Explorations, and Insights","date":"2024-11-01T04:00:00.000Z","introContent":"Implemented event loops in both Go and Python to gain insights into how they work.\nOptimization and Implementation of Parallelized Graph Algorithms for Shared Memory Architectures","keywords":["parallelization","C++","OpenMP","HPC","event-loop","single-thread","Go","Python"],"type":"implementation","link":"","content":"Implemented event loops in both Go and Python to gain insights into how they work.\nOptimization and Implementation of Parallelized Graph Algorithms for Shared Memory Architectures\n\nImplemented a framework for parallel graph algorithms on shared memory machines using OpenMP. Optimized the data access pattern, avoiding race conditions, to achieve a speedup of 8x for Bellman-Ford, 7x for Connected Components, and 3x for Breadth-First Search algorithms on a graph with 1 million vertices and 15 million edges.","toBeDisplayed":true},{"heading":"Implementation of Redis","date":"2024-11-01T04:00:00.000Z","introContent":"Implemented an event loop-based Redis server that can parse and read RDB files, read, write, and replicate in-memory storage, and support Redis streams and transactions.","keywords":["Redis","Go","distributed systems"],"type":"implementation","link":"","content":"Implemented an event loop-based Redis server that can parse and read RDB files, read, write, and replicate in-memory storage, and support Redis streams and transactions.","toBeDisplayed":true},{"heading":"Implementation of Git","date":"2024-10-01T04:00:00.000Z","introContent":"Implemented Git interface and plumbing commands to clone a repository from the remote.","keywords":["Git","TypeScript"],"type":"implementation","link":"","content":"Implemented Git interface and plumbing commands to clone a repository from the remote.","toBeDisplayed":true},{"heading":"Implementation of SQLite","date":"2024-10-01T04:00:00.000Z","introContent":"Implemented a version that can read SQLite database files and execute basic SQL queries like SELECT, WHERE, etc., using indexes.","keywords":["SQL","Go","relational database"],"type":"implementation","link":"","content":"Implemented a version that can read SQLite database files and execute basic SQL queries like SELECT, WHERE, etc., using indexes.","toBeDisplayed":true},{"heading":"Hands-on Implementation of Distributed Systems Protocols","date":"2022-12-01T05:00:00.000Z","introContent":"Implementation of the Chord Protocol-Based Distributed Hash Table for Peer-to-Peer Networks. Implemented a scalable key-value store using the Chord Protocol for decentralized networks. The Chord Protocol simplifies key lookup, node joining, and leaving processes, ensuring consistent behavior.","keywords":["distributed systems","Elixir","Raft","Go","gRPCs"],"type":"implementation","link":"","content":"Implementation of the Chord Protocol-Based Distributed Hash Table for Peer-to-Peer Networks. Implemented a scalable key-value store using the Chord Protocol for decentralized networks. The Chord Protocol simplifies key lookup, node joining, and leaving processes, ensuring consistent behavior. Conducted performance evaluations on fetch times by increasing the key count from 100K to 1.6M on a system with 100 nodes.\n\nImplemented a replicated state machine using Raft, a distributed consensus protocol, to ensure log consistency across replicas in the system. Implemented log replication and leader election to handle node failures and validated it using rigorous testing with simulated node failures.","toBeDisplayed":true}]